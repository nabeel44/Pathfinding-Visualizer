{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","_this$props","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","react_default","a","createElement","id","concat","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","nodesSortedByDistance","_step2","nodes","_iterator2","_createForOfIteratorHelper","s","n","done","_step3","value","_iterator3","node","push","err","e","f","getAllNodes","iterations","sort","nodeA","nodeB","currentNode","shift","Infinity","isVisited","setNeighborsNewDistance","_step","_iterator","neighbors","length","filter","neighbor","getNeighbors","previousNode","openList","getNextNode","visitedList","setAsVisited","item","doesThisNodeQualify","open","setAsOpen","bestNodeIndex","bestNodefCost","i","fCost","gCost","findNextNode","prevNode","manhattanDistance","xDistance","Math","abs","yDistance","hCost","PathfindingVisualizer","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","mouseIsPressed","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","_this2","_loop","setTimeout","animateShortestPathDijkstra","v","document","getElementById","_ret","_this3","_loop2","animateShortestPathAstar","_ret2","_loop3","_loop4","console","log","unshift","getNodesInShortestPathOrder","animateDijkstra","newNode","astar","nodesInShortestPathOrderAstar","getNodesInShortestPathOrderAstar","animateAstar","_this4","_this$state","Fragment","onClick","visualizeDijkstra","visualizeAstar","map","rowIdx","key","nodeIdx","Node_Node_Node","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","objectSpread","App","PathfindingVisualizer_PathfindingVisualizer_PathfindingVisualizer","reportWebVitals","onPerfEntry","Function","__webpack_require__","then","bind","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","render","StrictMode","src_App"],"mappings":"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","file":"static/js/main.37ed9807.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}","\n\nexport function dijkstra(grid, startNode, finishNode) {\n    let visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const nodesSortedByDistance = getAllNodes(grid);\n    let iterations = 0;\n    while (true && iterations < 10000) {\n        iterations += 1;\n      sortNodesByDistance(nodesSortedByDistance);\n      const currentNode = nodesSortedByDistance.shift();\n      if (currentNode == null) continue;\n      if (currentNode.isWall) continue;\n      if (currentNode.distance === Infinity) return visitedNodesInOrder;\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      if (currentNode === finishNode) return visitedNodesInOrder;\n      setNeighborsNewDistance(currentNode, grid);\n    }\n  }\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  \n  function setNeighborsNewDistance(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  export function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  export function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","import {getAllNodes} from '../algorithms/dijkstra';\nvar openList = [];\nvar currentNodeGlobal;\n\nexport function astar(grid, startNode, finishNode) {\n    //cases for not starting on finish node and stuff \n    let visitedList = [];\n    let newNode = startNode;\n    manhattanDistance(newNode);\n    while (true) {\n        console.log(newNode);\n        newNode = getNextNode(newNode, grid, visitedList);\n        if (typeof newNode === 'undefined') {\n            continue;\n        }\n        if (newNode === finishNode) {\n            visitedList = visitedList.filter(item => item !== startNode);\n            return visitedList;\n        }\n    }\n}\n\nfunction setAsOpen(node) {\n    node.open = true;\n}\n\nfunction setAsVisited(node) {\n    node.isVisited = true;\n}\n\nfunction setAsPath() {\n\n}\n\nfunction getNextNode(node, grid, visitedList) {\n    const {col, row} = node;\n\n    setAsVisited(node);\n    visitedList.push(node);\n    openList = openList.filter(item => item !== node) // removing the prev node from openList\n\n    if (row > 0) doesThisNodeQualify(grid[row - 1][col], node);\n    \n    if (row < grid.length - 1) doesThisNodeQualify(grid[row + 1][col], node);\n\n    if (col > 0) doesThisNodeQualify(grid[row][col - 1], node);\n\n    if (col < grid[0].length - 1) doesThisNodeQualify(grid[row][col + 1], node);\n\n    return findNextNode(node);\n}\n\nfunction doesThisNodeQualify(node, prevNode) {\n    if (node.open === false && node.isVisited === false && node.isWall === false) {\n        openList.push(node);\n        node.previousNode = prevNode;\n        manhattanDistance(node);\n    }\n}\n\nfunction findNextNode(node) {\n    setAsOpen(node)\n\n\n    let bestNodeIndex = 0\n    let bestNodefCost = 999;\n\n\n    for(let i = 0; i < openList.length; i++) {\n        if (openList[i].fCost < bestNodefCost) {\n            bestNodeIndex = i;\n            bestNodefCost = openList[i].fCost;\n        }\n        else if (openList[i].fCost === bestNodefCost) {\n            if (openList[i].gCost < openList[bestNodeIndex.gCost]) {\n                bestNodeIndex = i;\n            }\n        }\n    \n    }\n    let nextNode = openList[bestNodeIndex];\n    return nextNode;\n    }\n\nfunction manhattanDistance(node) {\n    const start_col = 15;\n    const start_row = 10;\n    const finish_col = 35;\n    const finish_row = 10;\n\n    const {col, row} = node;\n\n    //calculate gCost g(n) is the distance between the start node and the current node\n    let xDistance = Math.abs(col - start_col);\n    let yDistance = Math.abs(row - start_row);\n    node.gCost = xDistance + yDistance;\n\n    //calculate hCost h(n) is the distance between the current node and the finish node\n    xDistance = Math.abs(col - finish_col);\n    yDistance = Math.abs(row - finish_row);\n    node.hCost = xDistance + yDistance;\n\n    //calculate fCost f(n) is the sum of gCost and hCost\n    node.fCost = node.hCost + node.gCost;\n}\n\n\nexport function getNodesInShortestPathOrderAstar(startNode, finishNode) {\n    let currentNode = finishNode;\n    const nodesInShortestPathOrderAstar = [];\n\n    while (currentNode !== startNode) {\n        currentNode = currentNode.previousNode;\n        if (currentNode !== startNode) nodesInShortestPathOrderAstar.push(currentNode)\n    }\n    return nodesInShortestPathOrderAstar;\n}\n","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\nimport{astar, getNodesInShortestPathOrderAstar} from '../algorithms/astar';\n\nimport './PathfindingVisualizer.css';\nimport { FOCUSABLE_SELECTOR } from '@testing-library/user-event/dist/utils';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({grid});\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp() {\n    this.setState({mouseIsPressed: false});\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPathDijkstra(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animateAstar(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            this.animateShortestPathAstar(nodesInShortestPathOrder);\n          }, 30 * i);\n          return;\n        }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-visited';\n        }, 30 * i);\n      }\n\n  }\n\n  animateShortestPathAstar(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 50 * i);\n    }\n  }\n\n  animateShortestPathDijkstra(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 50 * i);\n    }\n  }\n  visualizeDijkstra() {\n    const {grid} = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    console.log(visitedNodesInOrder);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeAstar() {\n    const {grid} = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = astar(grid, startNode, finishNode);\n    console.log(visitedNodesInOrder);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(startNode, finishNode)\n    this.animateAstar(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n\n  \n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n    return (\n      <>\n        <button onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n        <button onClick={() => this.visualizeAstar()}>\n          Visualize A Star Search Algorithm\n        </button>\n        <div className=\"grid\">\n            Click And Drag to Place Walls\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    previousNode: null,\n    col,\n    row,\n    distance: Infinity,\n    fCost: null,\n    gCost: null,\n    hCost: null,\n    open: false,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    isVisited: false,\n    isWall: false, \n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}